<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        class MinHeap{
            constructor(){
                this.heap=[];
            }
            swap(i1,i2){
                const temp=this.heap[i1];
                this.heap[i1]=this.heap[i2];
                this.heap[i2]=temp;
            }
            getParentIndex(i){
                return Math.floor((i-1)/2);
            }
            getLeftIndex(i){
                return i*2+1;
            }
            getRightIndex(i){
                return i*2+2;
            }
            shiftUp(index){
                if(index==0){return;};
                const parentIndex=this.getParentIndex(index);
                if(this.heap[parentIndex]&&this.heap[parentIndex].value>this.heap[index].value){
                    this.swap(parentIndex,index);
                    //递归比较然后上移
                    this.shiftUp(parentIndex);
                }
            }
            shiftDown(index){
                const leftIndex=this.getLeftIndex(index);
                const rightIndex=this.getRightIndex(index);
                if(this.heap[leftIndex]&&this.heap[leftIndex].value<this.heap[index].value){
                    this.swap(leftIndex,index);
                    this.shiftDown(leftIndex);
                }
                if(this.heap[rightIndex]&&this.heap[rightIndex].value<this.heap[index].value){
                    this.swap(rightIndex,index);
                    this.shiftDown(rightIndex);
                }
            }
            insert(value){
                this.heap.push(value);
                this.shiftUp(this.heap.length-1);
            }
            //删除堆顶  用数组尾部元素替换堆顶(直接删除堆顶会破坏堆结构)
            //然后下移:将新堆顶和他的子节点交换至子节点大于等于这个新堆顶
            //大小为k的时间复杂度O（logk）
            pop(){
                this.heap[0]=this.heap.pop();
                this.shiftDown(0);
            }
            peek(){
                return this.heap[0];
            }
            size(){
                return this.heap.length;
            }
        }
        const map=new Map();
    nums.forEach(n=>{
        map.set(n,map.has(n)?map.get(n)+1:1);
    });
        const h=new MinHeap();
        map.forEach((value,key)=>{
            h.insert({value,key});
            if(h.size()>k){
                h.pop()
            }
        })
        //因为h里面heap是一个数组  里面是对象   所以map一下 找出来他们的值。
        //.map就是调用参数里面每个对象都应用后面的方法。
        return h.heap.map(a=>a.key);
    </script>
</head>
<body>
    <!-- 
        /**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
    const map=new Map();
    nums.forEach(n=>{
        map.set(n,map.has(n)?map.get(n)+1:1);
    });
    //频率相减 得出排序后的数组；
    const list=Array.from(map).sort((a,b)=>b[1]-a[1]);
    //前K个元素转换为map 然后找出他们的值
    return list.slice(0,k).map(n=>n[0]);
};


     -->
</body>
</html>